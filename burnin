#!/usr/bin/env bash

if [ "${EUID}" -ne 0 ]; then
   echo "This script must be run as root" 1>&2
   exit 1
fi

# Gets the progress of a running SMART test as a string, or outputs nothing if
# no test is currently running.
function get_smart_progress {
  local drive="${1}"

  smartctl -a "${drive}" | \
    grep 'of test remaining' | \
    sed 's/^[[:blank:]]*//' | \
    sed 's/\.$//'
}

# Fill the target device with a random stream of data.
function randomize {
  local device="${1}"

   cat /dev/zero \
     | openssl enc \
       -aes-256-ctr \
       -nosalt \
       -pass "pass:$(dd if=/dev/urandom bs=128 count=1 2> /dev/null | base64)" \
     | dd status=progress bs=64K of="${device}"
}

# Run a SMART test in offline mode and wait until it's done, printing remaining
# progress every minute.
function smart_test {
  local drive="${1}"
  local test_name="${2}"

  echo "Running ${test_name} SMART test on $(date):"
  smartctl --test=${test_name} "${drive}"

  # Wait for the progress remaining to disappear, signaling the end of the test.
  local result="NONEMPTY"
  while [ -n "${result}" ]; do
    result="$(get_smart_progress "${drive}")"

    echo "> ${result}"
    sleep 60
  done
}

# Run a succession of SMART tests and badblocks on a drive, and output the final
# results when complete.
function burnin {
  local drive=$1

  echo
  echo "Starting burn-in test for ${drive} on $(date):"

  echo
  echo "Aborting any running SMART tests on ${drive}:"
  smartctl -X "${drive}"

  echo
  echo "Current SMART status for ${drive}:"
  smartctl -a "${drive}"

  echo
  echo "Putting kernel in raw mode"
  sysctl kern.geom.debugflags=0x10

  echo
  smart_test "${drive}" "short"

  echo
  smart_test "${drive}" "conveyance"

  echo
  smart_test "${drive}" "long"

  # # This section runs a _destructive_ write/read test on the drive, exercising
  # # its memory cells and attempting to cause an early failure.
  # echo
  # echo "Running destructive badblocks test on $(date):"
  # badblocks -ws "${drive}"

  # # This section prepares the drive for later encryption. We write three times
  # # to ensure we "catch" all the spare area and such. This isn't perfect, but it
  # # should still do the job. See
  # # https://www.usenix.org/legacy/events/fast11/tech/full_papers/Wei.pdf for
  # # more information. It also has the "bonus" effect of exercising the drive
  # # some more before we run our final SMART test.
  # echo
  # echo "Overwriting drive with random data... (1/3)"
  # randomize "${drive}"
  # echo "Overwriting drive with random data... (2/3)"
  # randomize "${drive}"
  # echo "Overwriting drive with random data... (3/3)"
  # randomize "${drive}"

  echo
  smart_test "${drive}" "long"

  echo
  echo "Burn-in test completed on $(date)"

  echo
  echo "Burn-in test results:"
  smartctl -a "${drive}"
}

if [ -z "${1}" ]; then
  echo "Drive required as first argument"
  exit 1
fi

# Run the burn-in and see how long it takes, just for fun.
time burnin "${1}"
